ðŸŽ¯ BabelDOC + Gemini í†µí•© ìµœì¢… ê°œë°œ ê³„íšì„œ (ì™„ì„±ë³¸)

ìž‘ì„±ìž: ë‚¨ê´‘í˜„í˜„
ë¬¸ì„œ ëª©í‘œ: ì´ ë¬¸ì„œëŠ” ë‹¨ìˆœí•œ ê³„íšì„ ë„˜ì–´, í”„ë¡œì íŠ¸ì˜ ì² í•™, ì•„í‚¤í…ì²˜, ìƒì„¸ êµ¬í˜„, í…ŒìŠ¤íŠ¸, ë°°í¬ê¹Œì§€ ëª¨ë“  ë‹¨ê³„ë¥¼ ë§ë¼í•˜ëŠ” ì‹¤í–‰ ê°€ëŠ¥í•œ ê¸°ìˆ  ì²­ì‚¬ì§„(Technical Blueprint)ì„ ì œê³µí•˜ëŠ” ê²ƒì„ ëª©í‘œë¡œ í•©ë‹ˆë‹¤.

1. í”„ë¡œì íŠ¸ ê°œìš” (Project Overview)
1.1. ëª©í‘œ
ê¸°ì¡´ì˜ BabelDOC ë²ˆì—­ ì—”ì§„ì— Googleì˜ ì°¨ì„¸ëŒ€ ì–¸ì–´ ëª¨ë¸ì¸ gemini-2.5 ì‹œë¦¬ì¦ˆ APIë¥¼ ì™„ë²½í•˜ê²Œ í†µí•©í•©ë‹ˆë‹¤. ì´ë¥¼ í†µí•´, ì˜¨ë¼ì¸ ë²ˆì—­ê¸° ì‚¬ìš© ì‹œ ë°œìƒí•˜ëŠ” ë ˆì´ì•„ì›ƒ ê¹¨ì§ í˜„ìƒê³¼ ê¸°ê³„ì ì¸ ë²ˆì—­ í’ˆì§ˆì˜ í•œê³„ë¥¼ ëª¨ë‘ ê·¹ë³µí•˜ê³ , ì›ë³¸ ë¬¸ì„œì˜ ì‹œê°ì  êµ¬ì¡°ì™€ ì˜ë¯¸ì  ë‰˜ì•™ìŠ¤ë¥¼ ëª¨ë‘ ë³´ì¡´í•˜ëŠ” ìµœê³  ìˆ˜ì¤€ì˜ ë…ë¦½ ì‹¤í–‰í˜•(Standalone) í¬í„°ë¸” PDF ë²ˆì—­ê¸°ë¥¼ ê°œë°œí•˜ëŠ” ê²ƒì„ ìµœì¢… ëª©í‘œë¡œ ì‚¼ìŠµë‹ˆë‹¤.
1.2. í•µì‹¬ ê°€ì¹˜
â—	ì™„ë²½í•œ í˜•ì‹ ë³´ì¡´ (Flawless Layout Preservation): ë‹¨ìˆœ í…ìŠ¤íŠ¸ ì¶”ì¶œ ë°©ì‹ì´ ì•„ë‹Œ, BabelDOCì˜ ë…ìžì ì¸ ë Œë”ë§ ì—”ì§„ì„ í™œìš©í•˜ì—¬ í‘œ, ë‹¤ë‹¨(multi-column) êµ¬ì¡°, ë³µìž¡í•œ ê·¸ëž˜í”„, ì´ë¯¸ì§€ ë° ê°ì£¼ ìœ„ì¹˜ê¹Œì§€ ì›ë³¸ PDFì˜ ëª¨ë“  ì‹œê°ì  ìš”ì†Œë¥¼ ì™„ë²½í•˜ê²Œ ìœ ì§€í•©ë‹ˆë‹¤. ì‚¬ìš©ìžëŠ” ë²ˆì—­ í›„ ê¹¨ì§„ í‘œë‚˜ ì´ë¯¸ì§€ ìœ„ì¹˜ë¥¼ ìˆ˜ì •í•˜ëŠ” ë° ì‹œê°„ì„ ë‚­ë¹„í•  í•„ìš”ê°€ ì—†ìŠµë‹ˆë‹¤.
â—	ìµœê³  ìˆ˜ì¤€ì˜ ë²ˆì—­ í’ˆì§ˆ (State-of-the-Art Translation Quality): í˜„ì¡´ ìµœê³  ì„±ëŠ¥ì˜ gemini-2.5-pro ëª¨ë¸ì„ í•„ë‘ë¡œ, ì‚¬ìš©ìžê°€ ëª©ì (í’ˆì§ˆ, ì†ë„, ë¹„ìš©)ì— ë”°ë¼ ìµœì ì˜ ëª¨ë¸ì„ ì„ íƒí•  ìˆ˜ ìžˆëŠ” ì˜µì…˜ì„ ì œê³µí•©ë‹ˆë‹¤. ì´ëŠ” ë‹¨ìˆœ ì§ì—­ì„ ë„˜ì–´, ë¬¸ë§¥ì„ ê¹Šì´ ì´í•´í•˜ê³  ì „ë¬¸ ìš©ì–´ê¹Œì§€ ì •í™•í•˜ê²Œ ë²ˆì—­í•˜ëŠ” ì „ë¬¸ê°€ ìˆ˜ì¤€ì˜ ê²°ê³¼ë¬¼ì„ ë³´ìž¥í•©ë‹ˆë‹¤.
â—	ê¶ê·¹ì˜ ì‚¬ìš© íŽ¸ì˜ì„± (Ultimate User Experience): ë³µìž¡í•œ ì„¤ì¹˜ ê³¼ì •ì´ë‚˜ Python, ë¼ì´ë¸ŒëŸ¬ë¦¬ ë“± ì‚¬ì „ ì§€ì‹ì´ ì „í˜€ í•„ìš” ì—†ëŠ” ì›í´ë¦­ ì‹¤í–‰ í¬í„°ë¸” EXE íŒŒì¼ì„ ì œê³µí•©ë‹ˆë‹¤. USB ë©”ëª¨ë¦¬ ë“±ì— ë‹´ì•„ ì–´ë–¤ PCì—ì„œë“  ì¦‰ì‹œ ì‚¬ìš©í•  ìˆ˜ ìžˆìœ¼ë©°, ì§ê´€ì ì¸ GUIë¥¼ í†µí•´ ëˆ„êµ¬ë‚˜ ì†ì‰½ê²Œ ê³ í’ˆì§ˆ ë²ˆì—­ì„ ê²½í—˜í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
â—	ì•ˆì •ì„± ë° í™•ìž¥ì„± (Robustness & Scalability): ê²€ì¦ëœ BabelDOCì˜ í•µì‹¬ ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©´ì„œ, 'ë¸Œë¦¿ì§€' íŒ¨í„´ì„ í†µí•´ Gemini APIë¥¼ ìœ ì—°í•˜ê²Œ ì—°ë™í•©ë‹ˆë‹¤. ì´ ì•„í‚¤í…ì²˜ëŠ” í–¥í›„ Googleì´ ìƒˆë¡œìš´ ëª¨ë¸ì„ ì¶œì‹œí•˜ê±°ë‚˜, ë‹¤ë¥¸ AI APIë¥¼ ì¶”ê°€í•´ì•¼ í•  ê²½ìš°ì—ë„ ìµœì†Œí•œì˜ ì½”ë“œ ìˆ˜ì •ìœ¼ë¡œ ì‹ ì†í•˜ê²Œ ëŒ€ì‘í•  ìˆ˜ ìžˆëŠ” ë†’ì€ í™•ìž¥ì„±ì„ ì œê³µí•©ë‹ˆë‹¤.
1.3. ìµœì¢… ê²°ê³¼ë¬¼
â—	PDFë²ˆì—­ê¸°_ë‚¨ê´‘í˜„_Test.exe: ëª¨ë“  ì˜ì¡´ì„±ì´ í¬í•¨ëœ ë‹¨ì¼ ì‹¤í–‰ íŒŒì¼ìž…ë‹ˆë‹¤. .NET, Java ë“± ë³„ë„ì˜ ëŸ°íƒ€ìž„ ì„¤ì¹˜ ì—†ì´ Windows í™˜ê²½ì´ë¼ë©´ ì–´ë””ì„œë“  ì¦‰ì‹œ ì‹¤í–‰ ê°€ëŠ¥í•˜ë©°, ì˜¤í”„ë¼ì¸ ë²ˆì—­ì„ ìœ„í•œ BabelDOCì˜ í•„ìˆ˜ ì—ì…‹(í°íŠ¸ ë“±)ì´ ë‚´ìž¥ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.
â—	config.json: ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ í•µì‹¬ ì„¤ì •ì„ ë‹´ê³  ìžˆëŠ” ì™¸ë¶€ êµ¬ì„± íŒŒì¼ìž…ë‹ˆë‹¤. ì½”ë“œë¥¼ ì „í˜€ ëª¨ë¥´ëŠ” ì‚¬ìš©ìžë„ ë©”ëª¨ìž¥ìœ¼ë¡œ ì´ íŒŒì¼ì„ ì—´ì–´ ì§€ì› ëª¨ë¸ ëª©ë¡ì„ ìˆ˜ì •í•˜ê±°ë‚˜, ëª¨ë¸ ì„¤ëª…ì„ ë³€ê²½í•˜ëŠ” ë“± ì†ì‰¬ìš´ ì»¤ìŠ¤í„°ë§ˆì´ì§•ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
â—	README.md: ë‹¨ìˆœí•œ ì„¤ëª…ì„œë¥¼ ë„˜ì–´, í”„ë¡œì íŠ¸ì˜ ëª¨ë“  ê²ƒì„ ë‹´ì€ ì¢…í•© ê°€ì´ë“œìž…ë‹ˆë‹¤. í¬í•¨ë  ë‚´ìš©:
â—‹	ì‚¬ìš©ìž ë§¤ë‰´ì–¼: ìŠ¤í¬ë¦°ìƒ·ì„ í¬í•¨í•œ ë‹¨ê³„ë³„ ì‚¬ìš©ë²•, ê° ê¸°ëŠ¥ ì„¤ëª…, API í‚¤ ë°œê¸‰ ë°©ë²•.
â—‹	ë¬¸ì œ í•´ê²°(FAQ): 'ë²ˆì—­ì´ ì•ˆ ë¼ìš”', 'API í‚¤ ì˜¤ë¥˜ê°€ ë‚˜ìš”' ë“± í”ížˆ ë°œìƒí•˜ëŠ” ë¬¸ì œì™€ í•´ê²° ë°©ë²•.
â—‹	ê°œë°œìž ê°€ì´ë“œ: ì†ŒìŠ¤ ì½”ë“œ ë¹Œë“œ ë°©ë²•, ë””ë ‰í† ë¦¬ êµ¬ì¡° ì„¤ëª…, ê¸°ì—¬(Contribute) ë°©ë²• ì•ˆë‚´.
â—	ì „ì²´ ì†ŒìŠ¤ ì½”ë“œ: GitHub ë¦¬í¬ì§€í† ë¦¬ë¥¼ í†µí•´ ëª¨ë“  ì†ŒìŠ¤ ì½”ë“œë¥¼ ê³µê°œí•˜ì—¬ íˆ¬ëª…ì„±ì„ í™•ë³´í•˜ê³ , ì»¤ë®¤ë‹ˆí‹°ì˜ ì°¸ì—¬ì™€ ë°œì „ì„ ìœ ë„í•©ë‹ˆë‹¤.
2. ì‹œìŠ¤í…œ ì•„í‚¤í…ì²˜ (System Architecture)
2.1. í•µì‹¬ ì „ëžµ: OpenAI í˜¸í™˜ ë¸Œë¦¿ì§€ (OpenAI-Compatible Bridge)
ë³¸ í”„ë¡œì íŠ¸ì˜ ì•„í‚¤í…ì²˜ëŠ” ì•ˆì •ì„±, ìœ ì§€ë³´ìˆ˜ì„±, í™•ìž¥ì„±ì´ë¼ëŠ” ì„¸ ê°€ì§€ ì›ì¹™ì— ê¸°ë°˜í•©ë‹ˆë‹¤. BabelDOCì˜ ê¸°ì¡´ ì½”ë“œë² ì´ìŠ¤ë¥¼ ì§ì ‘ ìˆ˜ì •í•˜ì—¬ Gemini SDKë¥¼ í†µí•©í•˜ëŠ” ëŒ€ì‹ , 'Gemini-to-OpenAI ë¸Œë¦¿ì§€' ë¼ëŠ” ë¡œì»¬ í”„ë¡ì‹œ ì„œë²„ë¥¼ êµ¬í˜„í•˜ëŠ” ë°©ì‹ì„ ì±„íƒí•©ë‹ˆë‹¤. ì´ëŠ” ì†Œí”„íŠ¸ì›¨ì–´ ê³µí•™ì˜ 'ì–´ëŒ‘í„° íŒ¨í„´(Adapter Pattern)'ì„ ì‘ìš©í•œ ê²ƒìœ¼ë¡œ, ì„œë¡œ ë‹¤ë¥¸ ì¸í„°íŽ˜ì´ìŠ¤ë¥¼ ê°€ì§„ ë‘ ì‹œìŠ¤í…œì„ ë§¤ë„ëŸ½ê²Œ ì—°ê²°í•˜ëŠ” ê°€ìž¥ íš¨ìœ¨ì ì¸ ë°©ë²•ìž…ë‹ˆë‹¤.
â—	ìƒì„¸ ë™ìž‘ ì›ë¦¬ (Step-by-Step Workflow):
1.	[ì‚¬ìš©ìž] GUIì—ì„œ PDF íŒŒì¼ì„ ì„ íƒí•˜ê³  'ë²ˆì—­ ì‹œìž‘' ë²„íŠ¼ì„ í´ë¦­í•©ë‹ˆë‹¤.
2.	[GUI: main_window.py] ìž…ë ¥ê°’(íŒŒì¼ ê²½ë¡œ, API í‚¤ ë“±)ì„ ê²€ì¦í•˜ê³ , ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ì—¬ babeldocì˜ ë©”ì¸ ë¡œì§ì„ í˜¸ì¶œí•©ë‹ˆë‹¤. (GUIì˜ ì‘ë‹µì„±ì„ ìœ ì§€í•˜ê¸° ìœ„í•¨)
3.	[ë©”ì¸ ë¡œì§: main.py] --gemini í”Œëž˜ê·¸ê°€ í™œì„±í™”ëœ ê²ƒì„ í™•ì¸í•˜ê³ , gemini_bridge.pyì˜ start_gemini_bridge í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.
4.	[ë¸Œë¦¿ì§€: gemini_bridge.py] ì‚¬ìš© ê°€ëŠ¥í•œ í¬íŠ¸(ì˜ˆ: 51234)ë¥¼ ë™ì ìœ¼ë¡œ ì°¾ì•„ Flask ê¸°ë°˜ì˜ ê²½ëŸ‰ ì›¹ ì„œë²„ë¥¼ ì‚¬ìš©ìž PC ë‚´ë¶€(127.0.0.1)ì—ì„œë§Œ ì‹¤í–‰ì‹œí‚µë‹ˆë‹¤. ì´ ì„œë²„ëŠ” ì™¸ë¶€ì—ì„œ ì ‘ê·¼í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.
5.	[ë©”ì¸ ë¡œì§: main.py] ë¸Œë¦¿ì§€ ì„œë²„ì˜ ì£¼ì†Œ(http://127.0.0.1:51234)ë¥¼ ë°›ì•„, BabelDOCì˜ OpenAI ê´€ë ¨ ì¸ìˆ˜ì¸ --openai-base-url ê°’ì„ ì´ ì£¼ì†Œë¡œ ë®ì–´ì”ë‹ˆë‹¤.
6.	[BabelDOC ì½”ì–´ ì—”ì§„] ë²ˆì—­ì´ í•„ìš”í•œ í…ìŠ¤íŠ¸ë¥¼ OpenAI API í˜•ì‹ì˜ ìš”ì²­ìœ¼ë¡œ ë§Œë“¤ì–´ http://127.0.0.1:51234/v1/chat/completionsë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
7.	[ë¸Œë¦¿ì§€] ì´ ìš”ì²­ì„ ë°›ì€ í›„, ë‚´ìš©ì„ Gemini APIê°€ ì´í•´í•  ìˆ˜ ìžˆëŠ” í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
8.	[ë¸Œë¦¿ì§€] ë³€í™˜ëœ ìš”ì²­ì„ ì¸í„°ë„·ì„ í†µí•´ ì‹¤ì œ Googleì˜ Gemini API ì„œë²„(https://generativelanguage.googleapis.com)ë¡œ ì „ì†¡í•©ë‹ˆë‹¤.
9.	[ë¸Œë¦¿ì§€] Googleë¡œë¶€í„° ë°›ì€ ì‘ë‹µì„ ë‹¤ì‹œ BabelDOCì´ ì´í•´í•  ìˆ˜ ìžˆëŠ” OpenAI API í˜•ì‹ìœ¼ë¡œ ìž¬ë³€í™˜í•©ë‹ˆë‹¤.
10.	[BabelDOC ì½”ì–´ ì—”ì§„] ë¸Œë¦¿ì§€ë¡œë¶€í„° ë°›ì€ ë²ˆì—­ëœ í…ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ìµœì¢… ê²°ê³¼ë¬¼ PDF íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.
11.	[í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ] ë²ˆì—­ì´ ì™„ë£Œë˜ê±°ë‚˜ í”„ë¡œê·¸ëž¨ì´ ì¢…ë£Œë˜ë©´, ë©”ì¸ í”„ë¡œì„¸ìŠ¤ì™€ í•¨ê»˜ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰ë˜ë˜ ë¸Œë¦¿ì§€ ì„œë²„ ìŠ¤ë ˆë“œë„ ìžë™ìœ¼ë¡œ ì†Œë©¸í•©ë‹ˆë‹¤.
â—	ê¸°ëŒ€ íš¨ê³¼ (Extended Benefits):
â—‹	ì•ˆì •ì„±: ê²€ì¦ëœ BabelDOCì˜ í•µì‹¬ ë²ˆì—­ ë° ë Œë”ë§ ë¡œì§ì„ ì „í˜€ ê±´ë“œë¦¬ì§€ ì•Šìœ¼ë¯€ë¡œ, ì‚¬ì´ë“œ ì´íŽ™íŠ¸ ë°œìƒ ê°€ëŠ¥ì„±ì„ ì›ì²œì ìœ¼ë¡œ ì°¨ë‹¨í•©ë‹ˆë‹¤.
â—‹	ê°œë°œ íš¨ìœ¨: Gemini API ì—°ë™ê³¼ ê´€ë ¨ëœ ëª¨ë“  ë³µìž¡ì„±ì„ gemini_bridge.py íŒŒì¼ í•˜ë‚˜ì— ì‘ì§‘ì‹œì¼œ, ë¬¸ì œ ë°œìƒ ì‹œ ì¶”ì  ë° ìˆ˜ì •ì´ ë§¤ìš° ìš©ì´í•©ë‹ˆë‹¤.
â—‹	ë…ë¦½ì„± ë° ë””ë²„ê¹… ìš©ì´ì„±: ë¸Œë¦¿ì§€ ì„œë²„ëŠ” ë…ë¦½ì ìœ¼ë¡œ í…ŒìŠ¤íŠ¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ì˜ˆë¥¼ ë“¤ì–´, curlê³¼ ê°™ì€ ë„êµ¬ë¡œ ë¡œì»¬ ë¸Œë¦¿ì§€ ì„œë²„ì— ì§ì ‘ ìš”ì²­ì„ ë³´ë‚´ Gemini API ì—°ë™ ë¶€ë¶„ë§Œ ë”°ë¡œ ë””ë²„ê¹…í•˜ëŠ” ê²ƒì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
â—‹	ë¯¸ëž˜ í˜¸í™˜ì„±: ë§Œì•½ ë¯¸ëž˜ì— Anthropicì˜ Claudeë‚˜ ë‹¤ë¥¸ AI ëª¨ë¸ì„ ì¶”ê°€í•˜ê³  ì‹¶ë‹¤ë©´, claude_bridge.pyë¥¼ ìƒˆë¡œ ë§Œë“œëŠ” ê²ƒë§Œìœ¼ë¡œ ì†ì‰½ê²Œ ê¸°ëŠ¥ì„ í™•ìž¥í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
3. ìƒì„¸ êµ¬í˜„ ê³„íš (Detailed Implementation Plan)
3.1. ë””ë ‰í† ë¦¬ êµ¬ì¡°
BabelDOC-Gemini/
â”œâ”€â”€ babeldoc/                  # ê¸°ì¡´ BabelDOC ì†ŒìŠ¤ì½”ë“œ (ë˜ëŠ” ì„œë¸Œëª¨ë“ˆ)
â”‚   â”œâ”€â”€ translator/
â”‚   â”‚   â””â”€â”€ gemini_bridge.py   # [ì‹ ê·œ] Gemini APIì™€ BabelDOCì„ ì—°ê²°í•˜ëŠ” í†µì—­ì‚¬ ì—­í• 
â”‚   â””â”€â”€ main.py              # [ìˆ˜ì •] --gemini í”Œëž˜ê·¸ ì²˜ë¦¬ ë° ë¸Œë¦¿ì§€ ì‹¤í–‰ ë¡œì§ ì¶”ê°€
â”œâ”€â”€ gui/
â”‚   â””â”€â”€ main_window.py       # [ì‹ ê·œ] ì‚¬ìš©ìžê°€ ìƒí˜¸ìž‘ìš©í•  ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ì°½
â”œâ”€â”€ assets/
â”‚   â””â”€â”€ icon.ico             #      ì• í”Œë¦¬ì¼€ì´ì…˜ ì•„ì´ì½˜ íŒŒì¼
â”œâ”€â”€ build_exe.py             # [ì‹ ê·œ] ëª¨ë“  ì†ŒìŠ¤ì™€ ì˜ì¡´ì„±ì„ ë¬¶ì–´ .exe íŒŒì¼ë¡œ ë§Œë“œëŠ” ë¹Œë“œ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ config.json              # [ì‹ ê·œ] ì½”ë“œ ìˆ˜ì • ì—†ì´ ëª¨ë¸ ëª©ë¡ ë“±ì„ ë³€ê²½í•  ìˆ˜ ìžˆëŠ” ì„¤ì • íŒŒì¼
â””â”€â”€ requirements.txt         # [ì‹ ê·œ] í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ëª¨ë“  íŒŒì´ì¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ëª©ë¡

3.2. ì™¸ë¶€ ì„¤ì • íŒŒì¼ (config.json)
í•˜ë“œì½”ë”©ì„ í”¼í•˜ê³  ìœ ì—°ì„±ì„ ê·¹ëŒ€í™”í•˜ê¸° ìœ„í•´ ì™¸ë¶€ ì„¤ì • íŒŒì¼ì„ ì‚¬ìš©í•©ë‹ˆë‹¤. ì´ëŠ” ì½”ë“œì™€ ì„¤ì •ì„ ë¶„ë¦¬í•˜ëŠ” ì¢‹ì€ ê°œë°œ ê´€í–‰(Best Practice)ìž…ë‹ˆë‹¤.
{
  "supported_models": [
    "gemini-2.5-pro",
    "gemini-2.5-flash",
    "gemini-2.5-flash-lite"
  ],
  "model_descriptions": {
    "gemini-2.5-pro": "Pro (ìµœê³  í’ˆì§ˆ): ê°€ìž¥ ì™„ë²½í•˜ê³  ì •í™•í•œ ë²ˆì—­",
    "gemini-2.5-flash": "Flash (ê¶Œìž¥): í’ˆì§ˆê³¼ ì†ë„ì˜ ì™„ë²½í•œ ê· í˜•",
    "gemini-2.5-flash-lite": "Flash-Lite (ê³ ì†): ì‹ ì†í•œ ì´ˆë²Œ ë²ˆì—­ì— ìµœì "
  },
  "api_key_help_url": "https://aistudio.google.com/app/apikey"
}

3.3. Gemini-OpenAI ë¸Œë¦¿ì§€ (babeldoc/translator/gemini_bridge.py)
ì´ íŒŒì¼ì€ í”„ë¡œì íŠ¸ì˜ í•µì‹¬ ê¸°ìˆ ì´ ì§‘ì•½ëœ ë¶€ë¶„ìž…ë‹ˆë‹¤. Flaskë¥¼ ì´ìš©í•œ ê²½ëŸ‰ ì›¹ì„œë²„ë¡œ, ìƒì„¸í•œ ì˜¤ë¥˜ ì²˜ë¦¬ì™€ API ì‚¬ìš©ëŸ‰ ì œí•œ(Rate Limiting) ë¡œì§ì„ í¬í•¨í•©ë‹ˆë‹¤.
# babeldoc/translator/gemini_bridge.py

import google.generativeai as genai
from google.api_core import exceptions as google_exceptions
from flask import Flask, request, jsonify
import threading
import time
import logging
import socket
from typing import Tuple

# ë¡œê¹… ê¸°ë³¸ ì„¤ì •: ë¬¸ì œ ë°œìƒ ì‹œ ì›ì¸ ì¶”ì ì„ ìœ„í•œ ìƒì„¸ ë¡œê·¸ë¥¼ ê¸°ë¡í•©ë‹ˆë‹¤.
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - [GeminiBridge] - %(message)s')

class GeminiOpenAIBridge:
    """
    Gemini APIë¥¼ OpenAI ChatCompletion APIì™€ í˜¸í™˜ë˜ëŠ” ë¡œì»¬ ì„œë²„ë¡œ ëž˜í•‘í•©ë‹ˆë‹¤.
    QPS ì œí•œ, ìƒì„¸ ì˜¤ë¥˜ ì²˜ë¦¬ ê¸°ëŠ¥ì´ í¬í•¨ë˜ì–´ ìžˆìŠµë‹ˆë‹¤.
    """
    def __init__(self, api_key: str, model: str, qps: float):
        self.api_key = api_key
        self.model = model
        self.qps = qps
        self.last_request_time = 0
        self.logger = logging.getLogger(__name__)

        try:
            # Google Gemini í´ë¼ì´ì–¸íŠ¸ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
            genai.configure(api_key=self.api_key)
            self.client = genai.GenerativeModel(self.model)
            self.logger.info(f"Gemini í´ë¼ì´ì–¸íŠ¸ê°€ '{self.model}' ëª¨ë¸ë¡œ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.")
        except Exception as e:
            self.logger.error(f"Gemini í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise

        self.app = Flask(__name__)
        self.setup_routes()

    def setup_routes(self):
        """OpenAI í˜¸í™˜ API ì—”ë“œí¬ì¸íŠ¸ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤. BabelDOCì€ ì´ ì£¼ì†Œë¡œ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤."""
        @self.app.route('/v1/chat/completions', methods=['POST'])
        def chat_completions():
            return self.handle_chat_completions()

    def handle_chat_completions(self):
        """OpenAI ChatCompletion API ìš”ì²­ì„ ì²˜ë¦¬í•˜ê³  Gemini APIë¡œ ë³€í™˜í•˜ì—¬ ì‘ë‹µí•©ë‹ˆë‹¤."""
        try:
            # API ê³¼ë‹¤ ì‚¬ìš©ì„ ë°©ì§€í•˜ê¸° ìœ„í•´ QPS ì œí•œì„ ë¨¼ì € ì ìš©í•©ë‹ˆë‹¤.
            self.apply_rate_limit()

            data = request.json
            messages = data.get('messages', [])
            
            # BabelDOCì´ ë³´ë‚¸ ë©”ì‹œì§€ ëª©ë¡ì—ì„œ ì‹¤ì œ ë²ˆì—­í•  ë‚´ìš©ì„ ì¶”ì¶œí•©ë‹ˆë‹¤.
            user_message = ""
            for msg in reversed(messages):
                if msg.get('role') == 'user':
                    user_message = msg.get('content', '')
                    break
            
            if not user_message:
                self.logger.warning("ìš”ì²­ì—ì„œ ì‚¬ìš©ìž ë©”ì‹œì§€ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
                return jsonify({"error": "No user message found"}), 400

            self.logger.info(f"'{self.model}' ëª¨ë¸ë¡œ ë²ˆì—­ ìš”ì²­ì„ ë³´ëƒ…ë‹ˆë‹¤. (ë‚´ìš© ì¼ë¶€: {user_message[:50]}...)")
            
            # Gemini API í˜¸ì¶œ ë° ë°œìƒ ê°€ëŠ¥í•œ ì˜¤ë¥˜ë“¤ì„ ìƒì„¸í•˜ê²Œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
            try:
                response = self.client.generate_content(user_message)
                translated_text = response.text
                
                # Gemini ì‘ë‹µì„ BabelDOCì´ ì´í•´í•  ìˆ˜ ìžˆëŠ” OpenAI í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
                openai_response = self.format_as_openai_response(translated_text, user_message)
                self.logger.info("ë²ˆì—­ ì„±ê³µ. OpenAI í˜•ì‹ìœ¼ë¡œ ì‘ë‹µì„ ë°˜í™˜í•©ë‹ˆë‹¤.")
                return jsonify(openai_response)

            # API í‚¤ê°€ ìž˜ëª»ë˜ì—ˆì„ ê²½ìš°
            except google_exceptions.PermissionDenied as e:
                self.logger.error(f"Gemini API ê¶Œí•œ ì˜¤ë¥˜: {e}")
                return jsonify({"error": {"message": "ìž˜ëª»ëœ Gemini API í‚¤ìž…ë‹ˆë‹¤. í‚¤ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.", "type": "invalid_request_error", "code": "invalid_api_key"}}), 401
            # API ì‚¬ìš©ëŸ‰ í•œë„ë¥¼ ì´ˆê³¼í–ˆì„ ê²½ìš°
            except google_exceptions.ResourceExhausted as e:
                self.logger.error(f"Gemini API í• ë‹¹ëŸ‰ ì´ˆê³¼: {e}")
                return jsonify({"error": {"message": "API í• ë‹¹ëŸ‰ì„ ì´ˆê³¼í–ˆìŠµë‹ˆë‹¤. ìž ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•˜ê±°ë‚˜ Google Cloud ì½˜ì†”ì—ì„œ í• ë‹¹ëŸ‰ì„ í™•ì¸í•˜ì„¸ìš”.", "type": "insufficient_quota", "code": "quota_exceeded"}}), 429
            # ê·¸ ì™¸ ëª¨ë“  Gemini API ê´€ë ¨ ì˜¤ë¥˜
            except Exception as e:
                self.logger.error(f"Gemini API í˜¸ì¶œ ì¤‘ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ ë°œìƒ: {e}")
                return jsonify({"error": {"message": f"ë²ˆì—­ ì‹¤íŒ¨: {str(e)}", "type": "api_error"}}), 500

        # ìš”ì²­ ì²˜ë¦¬ ê³¼ì • ìžì²´ì—ì„œ ë°œìƒí•œ ì˜¤ë¥˜
        except Exception as e:
            self.logger.error(f"ìš”ì²­ ì²˜ë¦¬ ì¤‘ ë‚´ë¶€ ì˜¤ë¥˜ ë°œìƒ: {e}")
            return jsonify({"error": {"message": f"Request processing failed: {str(e)}", "type": "internal_error"}}), 500

    def apply_rate_limit(self):
        """QPS(ì´ˆë‹¹ ìš”ì²­ ìˆ˜) ì œí•œì„ ì ìš©í•˜ì—¬ API ì„œë²„ì— ê³¼ë„í•œ ë¶€í•˜ë¥¼ ì£¼ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤."""
        current_time = time.time()
        time_since_last = current_time - self.last_request_time
        min_interval = 1.0 / self.qps if self.qps > 0 else 0
        
        if time_since_last < min_interval:
            sleep_time = min_interval - time_since_last
            self.logger.info(f"QPS ì œí•œ({self.qps}/s)ì„ ìœ„í•´ {sleep_time:.2f}ì´ˆ ëŒ€ê¸°í•©ë‹ˆë‹¤.")
            time.sleep(sleep_time)
        
        self.last_request_time = time.time()

    def format_as_openai_response(self, translated_text: str, original_text: str) -> dict:
        """Gemini ì‘ë‹µì„ OpenAI ChatCompletion ì‘ë‹µ í˜•ì‹ìœ¼ë¡œ ë³€í™˜í•©ë‹ˆë‹¤."""
        return {
            "id": f"chatcmpl-{int(time.time())}",
            "object": "chat.completion",
            "created": int(time.time()),
            "model": self.model,
            "choices": [{
                "index": 0,
                "message": {
                    "role": "assistant",
                    "content": translated_text
                },
                "finish_reason": "stop"
            }],
            "usage": {
                "prompt_tokens": len(original_text.split()),
                "completion_tokens": len(translated_text.split()),
                "total_tokens": len(original_text.split()) + len(translated_text.split())
            }
        }

    def start_server(self, host: str, port: int):
        """Flask ì„œë²„ë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤."""
        self.logger.info(f"Gemini-OpenAI ë¸Œë¦¿ì§€ ì„œë²„ë¥¼ {host}:{port}ì—ì„œ ì‹œìž‘í•©ë‹ˆë‹¤.")
        # Werkzeugì˜ ê¸°ë³¸ ë¡œê±° ë¹„í™œì„±í™”í•˜ì—¬ GUI ë¡œê·¸ì°½ì— ì¤‘ë³µ ë¡œê·¸ê°€ ì°ížˆëŠ” ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.
        log = logging.getLogger('werkzeug')
        log.setLevel(logging.ERROR)
        self.app.run(host=host, port=port, debug=False, threaded=True)

def find_free_port() -> int:
    """ë‹¤ë¥¸ í”„ë¡œê·¸ëž¨ê³¼ ì¶©ëŒí•˜ì§€ ì•Šë„ë¡ ì‚¬ìš© ê°€ëŠ¥í•œ í¬íŠ¸ë¥¼ ë™ì ìœ¼ë¡œ ì°¾ìŠµë‹ˆë‹¤."""
    with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
        s.bind(('', 0))
        return s.getsockname()[1]

def start_gemini_bridge(api_key: str, model: str, qps: float) -> Tuple[str, int]:
    """
    ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ Gemini ë¸Œë¦¿ì§€ ì„œë²„ë¥¼ ì‹œìž‘í•˜ê³ ,
    ì„œë²„ì˜ base_urlê³¼ í¬íŠ¸ ë²ˆí˜¸ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.
    """
    port = find_free_port()
    host = '127.0.0.1'
    
    try:
        bridge = GeminiOpenAIBridge(api_key, model, qps)
        server_thread = threading.Thread(
            target=bridge.start_server, 
            args=(host, port),
            daemon=True # ë©”ì¸ í”„ë¡œê·¸ëž¨ì´ ì¢…ë£Œë˜ë©´ ì´ ìŠ¤ë ˆë“œë„ ìžë™ìœ¼ë¡œ ì¢…ë£Œë©ë‹ˆë‹¤.
        )
        server_thread.start()
        time.sleep(2) # ì„œë²„ê°€ ì™„ì „ížˆ ì‹œìž‘ë  ë•Œê¹Œì§€ ìž ì‹œ ëŒ€ê¸°í•©ë‹ˆë‹¤.
        
        base_url = f"http://{host}:{port}"
        logging.info(f"ë¸Œë¦¿ì§€ ì„œë²„ê°€ {base_url} ì—ì„œ ì„±ê³µì ìœ¼ë¡œ ì‹œìž‘ë˜ì—ˆìŠµë‹ˆë‹¤.")
        return base_url, port
    except Exception as e:
        logging.error(f"ë¸Œë¦¿ì§€ ì„œë²„ ì‹œìž‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}")
        raise

3.4. ë©”ì¸ ë¡œì§ ìˆ˜ì • (babeldoc/main.py)
ê¸°ì¡´ BabelDOCì˜ ëª…ë ¹ì¤„ ì¸í„°íŽ˜ì´ìŠ¤(CLI)ë¥¼ í™•ìž¥í•˜ì—¬ --gemini ê´€ë ¨ ì˜µì…˜ì„ ì¶”ê°€í•˜ê³ , ì´ ì˜µì…˜ì´ ì‚¬ìš©ë  ë•Œ ë¸Œë¦¿ì§€ ì„œë²„ë¥¼ êµ¬ë™í•˜ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.
# babeldoc/main.py (ê¸°ì¡´ íŒŒì¼ì— ì•„ëž˜ ë‚´ìš©ì„ ì¶”ê°€/ìˆ˜ì •)

import argparse
import sys
# ... (ê¸°ì¡´ import) ...
from .translator.gemini_bridge import start_gemini_bridge # ë¸Œë¦¿ì§€ ì‹œìž‘ í•¨ìˆ˜ë¥¼ import í•©ë‹ˆë‹¤.

def add_gemini_arguments(parser):
    """Gemini API ê´€ë ¨ ëª…ë ¹ì¤„ ì¸ìˆ˜ë¥¼ ArgumentParserì— ì¶”ê°€í•©ë‹ˆë‹¤."""
    gemini_group = parser.add_argument_group(
        'Gemini API Options',
        'Use Google Gemini API via a local OpenAI-compatible bridge.'
    )
    
    gemini_group.add_argument(
        '--gemini',
        action='store_true',
        help='[ì¶”ì²œ] Google Gemini APIë¥¼ ì‚¬ìš©í•˜ì—¬ ë²ˆì—­í•©ë‹ˆë‹¤. ì´ ì˜µì…˜ì„ ì‚¬ìš©í•˜ë©´ OpenAI ê´€ë ¨ ì˜µì…˜ë“¤ì´ ìžë™ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.'
    )
    
    gemini_group.add_argument(
        '--gemini-model',
        default='gemini-2.5-flash', # ì‚¬ìš©ìžê°€ ê°€ìž¥ ì„ í˜¸í•  ê²ƒìœ¼ë¡œ ì˜ˆìƒë˜ëŠ” 'flash' ëª¨ë¸ì„ ê¸°ë³¸ê°’ìœ¼ë¡œ ì„¤ì •
        help='ì‚¬ìš©í•  Gemini ëª¨ë¸ (ê¸°ë³¸ê°’: gemini-2.5-flash)'
    )
    
    gemini_group.add_argument(
        '--gemini-api-key',
        help='Google Gemini ì„œë¹„ìŠ¤ì˜ API í‚¤. GUIì—ì„œëŠ” ìž…ë ¥ í•„ë“œë¥¼ í†µí•´ ë°›ìŠµë‹ˆë‹¤.'
    )
    
    gemini_group.add_argument(
        '--gemini-qps',
        type=float,
        default=0.25,  # Google Gemini ë¬´ë£Œ í‹°ì–´ì˜ ë¶„ë‹¹ 15íšŒ ìš”ì²­(15 RPM) ì œí•œì„ ì¤€ìˆ˜í•˜ê¸° ìœ„í•œ ê¸°ë³¸ê°’
        help='Gemini APIì˜ QPS(ì´ˆë‹¹ ìš”ì²­ ìˆ˜) ì œí•œ (ê¸°ë³¸ê°’: 0.25)'
    )

def main():
    parser = argparse.ArgumentParser(description="Translate PDF files while maintaining the original layout.")
    # ... (ê¸°ì¡´ BabelDOC ì¸ìˆ˜ ì¶”ê°€ ë¡œì§) ...
    add_gemini_arguments(parser) # Gemini ê´€ë ¨ ì¸ìˆ˜ë¥¼ íŒŒì„œì— ë“±ë¡í•©ë‹ˆë‹¤.
    
    args = parser.parse_args()
    
    # --- Gemini ë¸Œë¦¿ì§€ ì‹¤í–‰ ë¡œì§ ---
    # ì‚¬ìš©ìžê°€ --gemini ì˜µì…˜ì„ ì£¼ì—ˆì„ ê²½ìš°ì—ë§Œ ì´ ë¸”ë¡ì´ ì‹¤í–‰ë©ë‹ˆë‹¤.
    if args.gemini:
        print("ðŸš€ Gemini ëª¨ë“œê°€ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. ë¡œì»¬ ë¸Œë¦¿ì§€ ì„œë²„ë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤...")
        
        if not args.gemini_api_key:
            print("âŒ ì˜¤ë¥˜: --gemini ì˜µì…˜ì„ ì‚¬ìš©í•˜ë ¤ë©´ --gemini-api-keyë¥¼ ë°˜ë“œì‹œ ì œê³µí•´ì•¼ í•©ë‹ˆë‹¤.", file=sys.stderr)
            sys.exit(1)
        
        try:
            # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë¸Œë¦¿ì§€ ì„œë²„ë¥¼ ì‹œìž‘í•˜ê³ , í†µì‹ ì— ì‚¬ìš©í•  ì£¼ì†Œì™€ í¬íŠ¸ë¥¼ ë°›ì•„ì˜µë‹ˆë‹¤.
            base_url, port = start_gemini_bridge(
                api_key=args.gemini_api_key, 
                model=args.gemini_model, 
                qps=args.gemini_qps
            )
            
            # BabelDOCì˜ OpenAI ê´€ë ¨ ì„¤ì •ì„ ë¸Œë¦¿ì§€ ì„œë²„ì— ë§žê²Œ ë™ì ìœ¼ë¡œ ë®ì–´ì”ë‹ˆë‹¤.
            # ì´ë¡œì¨ BabelDOCì€ ìžì‹ ì´ Geminiê°€ ì•„ë‹Œ OpenAIì™€ í†µì‹ í•œë‹¤ê³  'ì°©ê°'í•˜ê²Œ ë©ë‹ˆë‹¤.
            args.openai = True
            args.openai_base_url = base_url
            args.openai_api_key = "DUMMY_KEY_FOR_BRIDGE" # ë¸Œë¦¿ì§€ëŠ” ì´ í‚¤ë¥¼ ê²€ì¦í•˜ì§€ ì•Šìœ¼ë¯€ë¡œ ì•„ë¬´ ê°’ì´ë‚˜ ìƒê´€ì—†ìŠµë‹ˆë‹¤.
            args.openai_model = args.gemini_model # ëª¨ë¸ ì´ë¦„ì€ ê·¸ëŒ€ë¡œ ì „ë‹¬í•˜ì—¬ ì¼ê´€ì„±ì„ ìœ ì§€í•©ë‹ˆë‹¤.
            args.qps = args.gemini_qps # QPS ì„¤ì •ë„ ë™ê¸°í™”í•©ë‹ˆë‹¤.
            
            print(f"âœ… Gemini ë¸Œë¦¿ì§€ ì„œë²„ê°€ {base_url} ì—ì„œ ì„±ê³µì ìœ¼ë¡œ ì‹œìž‘ë˜ì—ˆìŠµë‹ˆë‹¤.")
            print("BabelDOCì´ ì´ ë¡œì»¬ ì„œë²„ë¥¼ í†µí•´ ë²ˆì—­ì„ ì§„í–‰í•©ë‹ˆë‹¤.")

        except Exception as e:
            print(f"âŒ Gemini ë¸Œë¦¿ì§€ ì„œë²„ ì‹œìž‘ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤: {e}", file=sys.stderr)
            sys.exit(1)
            
    # ... (ê¸°ì¡´ BabelDOC ë©”ì¸ ë¡œì§ ê³„ì†) ...
    # ì˜ˆ: run_translation_workflow(args) ì™€ ê°™ì€ í•¨ìˆ˜ í˜¸ì¶œ

3.5. GUI ê°œë°œ (gui/main_window.py)
customtkinterë¥¼ ì‚¬ìš©í•˜ê³ , ì‹¤ì‹œê°„ ë¡œê·¸ ë° ì§„í–‰ë¥  í‘œì‹œ, í”„ë¡œê·¸ëž¨ ëª…ì¹­ ë³€ê²½ ë“± ëª¨ë“  ì œì•ˆ ì‚¬í•­ì„ ë°˜ì˜í•œ ìµœì¢… GUI ì½”ë“œìž…ë‹ˆë‹¤.
# gui/main_window.py

import customtkinter as ctk
from tkinter import filedialog, messagebox
import threading
import subprocess
import json
import os
import sys
import webbrowser
from pathlib import Path
import re  # ì§„í–‰ë¥  íŒŒì‹±ì„ ìœ„í•œ ì •ê·œí‘œí˜„ì‹ ëª¨ë“ˆ

# PyInstallerë¡œ ë¹Œë“œëœ .exe í™˜ê²½ê³¼ ì¼ë°˜ .py ì‹¤í–‰ í™˜ê²½ ëª¨ë‘ì—ì„œ íŒŒì¼ ê²½ë¡œë¥¼ ì˜¬ë°”ë¥´ê²Œ ì°¾ê¸° ìœ„í•œ í•¨ìˆ˜
def get_base_path():
    if getattr(sys, 'frozen', False):
        return Path(sys._MEIPASS)
    return Path(__file__).parent.parent

BASE_PATH = get_base_path()
CONFIG_FILE = BASE_PATH / "config.json"
APP_NAME = "PDFë²ˆì—­ê¸°_ë‚¨ê´‘í˜„_Test" # í”„ë¡œê·¸ëž¨ ì´ë¦„ ë³€ìˆ˜í™”

class PDFTranslatorGUI:
    def __init__(self):
        # --- ê¸°ë³¸ ì„¤ì • ---
        ctk.set_appearance_mode("System")
        ctk.set_default_color_theme("blue")
        
        self.root = ctk.CTk()
        self.root.title(APP_NAME)
        self.root.geometry("850x750")
        self.root.minsize(800, 700)

        # --- ì„¤ì • ë¡œë“œ ---
        self.config = self.load_config()

        # --- UI ìƒíƒœ ë³€ìˆ˜ ì„ ì–¸ ---
        self.file_path = ctk.StringVar()
        self.target_lang = ctk.StringVar(value="ko")
        self.output_format = ctk.StringVar(value="both")
        self.api_key = ctk.StringVar()
        self.ai_model = ctk.StringVar(value=self.config["supported_models"][1])

        self.is_translating = False
        
        # --- ìœ„ì ¯ ìƒì„± ---
        self.create_widgets()

    def load_config(self):
        """config.json íŒŒì¼ì—ì„œ ì„¤ì •ì„ ë¡œë“œí•©ë‹ˆë‹¤."""
        try:
            with open(CONFIG_FILE, 'r', encoding='utf-8') as f:
                return json.load(f)
        except FileNotFoundError:
            messagebox.showerror("ì¹˜ëª…ì  ì˜¤ë¥˜", f"ì„¤ì • íŒŒì¼({CONFIG_FILE})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. í”„ë¡œê·¸ëž¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            sys.exit(1)
        except json.JSONDecodeError:
            messagebox.showerror("ì¹˜ëª…ì  ì˜¤ë¥˜", f"ì„¤ì • íŒŒì¼({CONFIG_FILE})ì˜ í˜•ì‹ì´ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤. í”„ë¡œê·¸ëž¨ì„ ì¢…ë£Œí•©ë‹ˆë‹¤.")
            sys.exit(1)

    def create_widgets(self):
        """ì• í”Œë¦¬ì¼€ì´ì…˜ì˜ ëª¨ë“  UI ìš”ì†Œë¥¼ ìƒì„±í•˜ê³  ë°°ì¹˜í•©ë‹ˆë‹¤."""
        main_frame = ctk.CTkFrame(self.root)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)
        
        main_frame.grid_columnconfigure(0, weight=1)
        main_frame.grid_rowconfigure(5, weight=1)

        # 1. ì œëª©
        ctk.CTkLabel(main_frame, text="ðŸŽ¯ PDF ë²ˆì—­ê¸° (BabelDOC + Gemini)", font=ctk.CTkFont(size=24, weight="bold")).grid(row=0, column=0, pady=(10, 20))

        # 2. íŒŒì¼ ì„ íƒ
        self.create_file_selection(main_frame).grid(row=1, column=0, sticky="ew", padx=20, pady=10)
        
        # 3. ì„¤ì • (ì–¸ì–´, ì¶œë ¥, ëª¨ë¸)
        self.create_settings_frame(main_frame).grid(row=2, column=0, sticky="ew", padx=20, pady=10)

        # 4. API í‚¤ ìž…ë ¥
        self.create_api_key_input(main_frame).grid(row=3, column=0, sticky="ew", padx=20, pady=10)

        # 5. ë²ˆì—­ ë²„íŠ¼
        self.translate_btn = ctk.CTkButton(main_frame, text="ðŸš€ ë²ˆì—­ ì‹œìž‘í•˜ê¸°", command=self.start_translation, height=50, font=ctk.CTkFont(size=16, weight="bold"))
        self.translate_btn.grid(row=4, column=0, pady=20, padx=20, sticky="ew")

        # 6. ì§„í–‰ ìƒí™© ë° ë¡œê·¸
        self.create_progress_section(main_frame).grid(row=5, column=0, sticky="nsew", padx=20, pady=10)

        # 7. í‘¸í„° (í”„ë¡œê·¸ëž¨ëª… í‘œì‹œ)
        footer_label = ctk.CTkLabel(main_frame, text=APP_NAME, font=ctk.CTkFont(size=10), text_color="gray")
        footer_label.grid(row=6, column=0, pady=(10, 0), sticky="e")

    def create_section_frame(self, parent, title):
        frame = ctk.CTkFrame(parent)
        ctk.CTkLabel(frame, text=title, font=ctk.CTkFont(size=16, weight="bold")).pack(pady=(10, 5), anchor="w", padx=20)
        return frame

    def create_file_selection(self, parent):
        frame = self.create_section_frame(parent, "ðŸ“‚ 1. ë²ˆì—­í•  PDF íŒŒì¼ ì„ íƒ")
        file_frame = ctk.CTkFrame(frame, fg_color="transparent")
        file_frame.pack(fill="x", padx=20, pady=(5, 15))
        file_frame.grid_columnconfigure(0, weight=1)
        file_entry = ctk.CTkEntry(file_frame, textvariable=self.file_path, placeholder_text="ì—¬ê¸°ë¥¼ í´ë¦­í•˜ì—¬ íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”...")
        file_entry.grid(row=0, column=0, sticky="ew", padx=(0, 10))
        browse_btn = ctk.CTkButton(file_frame, text="ì°¾ì•„ë³´ê¸°", command=self.browse_file, width=100)
        browse_btn.grid(row=0, column=1)
        return frame

    def create_settings_frame(self, parent):
        frame = self.create_section_frame(parent, "âš™ï¸ 2. ë²ˆì—­ ì˜µì…˜ ì„¤ì •")
        frame.columnconfigure((0,1), weight=1)
        left_frame = ctk.CTkFrame(frame, fg_color="transparent")
        left_frame.grid(row=0, column=0, padx=20, pady=5, sticky="ew")
        ctk.CTkLabel(left_frame, text="ë²ˆì—­ ì–¸ì–´ (ëŒ€ìƒ)").pack(anchor="w")
        ctk.CTkComboBox(left_frame, values=["ko (í•œêµ­ì–´)", "en (ì˜ì–´)", "ja (ì¼ë³¸ì–´)", "zh (ì¤‘êµ­ì–´)"], variable=self.target_lang).pack(fill="x")
        ctk.CTkLabel(left_frame, text="ì¶œë ¥ í˜•ì‹").pack(anchor="w", pady=(10,0))
        ctk.CTkRadioButton(left_frame, text="ë²ˆì—­ë³¸ë§Œ", variable=self.output_format, value="mono").pack(anchor="w")
        ctk.CTkRadioButton(left_frame, text="ì´ì¤‘ì–¸ì–´ë³¸ë§Œ", variable=self.output_format, value="dual").pack(anchor="w")
        ctk.CTkRadioButton(left_frame, text="ë‘˜ ë‹¤ ìƒì„±", variable=self.output_format, value="both").pack(anchor="w")
        right_frame = ctk.CTkFrame(frame, fg_color="transparent")
        right_frame.grid(row=0, column=1, padx=20, pady=5, sticky="ew")
        ctk.CTkLabel(right_frame, text="AI ëª¨ë¸ ì„ íƒ").pack(anchor="w")
        for model in self.config["supported_models"]:
            desc = self.config["model_descriptions"].get(model, "")
            ctk.CTkRadioButton(right_frame, text=f"{model}\n({desc})", variable=self.ai_model, value=model).pack(anchor="w", pady=2)
        return frame

    def create_api_key_input(self, parent):
        frame = self.create_section_frame(parent, "ðŸ”‘ 3. Google Gemini API í‚¤")
        frame.columnconfigure(0, weight=1)
        api_entry = ctk.CTkEntry(frame, textvariable=self.api_key, placeholder_text="API í‚¤ë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ìœ¼ì„¸ìš”...", show="*")
        api_entry.grid(row=0, column=0, padx=20, pady=5, sticky="ew")
        help_frame = ctk.CTkFrame(frame, fg_color="transparent")
        help_frame.grid(row=0, column=1, padx=(0, 20))
        help_btn = ctk.CTkButton(help_frame, text="API í‚¤ ë°œê¸‰ë°›ê¸°", command=self.open_api_key_url, width=120)
        help_btn.pack()
        return frame

    def create_progress_section(self, parent):
        frame = self.create_section_frame(parent, "ðŸ”„ ì§„í–‰ ìƒí™© ë° ë¡œê·¸")
        frame.grid_columnconfigure(0, weight=1)
        frame.grid_rowconfigure(1, weight=1)
        self.progress = ctk.CTkProgressBar(frame)
        self.progress.grid(row=0, column=0, sticky="ew", padx=20, pady=5)
        self.progress.set(0)
        self.log_textbox = ctk.CTkTextbox(frame, state="disabled", wrap="word", font=ctk.CTkFont(family="Courier New", size=12))
        self.log_textbox.grid(row=1, column=0, sticky="nsew", padx=20, pady=(5, 15))
        return frame

    def browse_file(self):
        if self.is_translating: return
        file_path = filedialog.askopenfilename(title="ë²ˆì—­í•  PDF íŒŒì¼ì„ ì„ íƒí•˜ì„¸ìš”", filetypes=[("PDF files", "*.pdf")])
        if file_path:
            self.file_path.set(file_path)

    def open_api_key_url(self):
        webbrowser.open_new_tab(self.config["api_key_help_url"])

    def update_log(self, text):
        """ë°±ê·¸ë¼ìš´ë“œ ìŠ¤ë ˆë“œì—ì„œ UIë¥¼ ì•ˆì „í•˜ê²Œ ì—…ë°ì´íŠ¸í•˜ê¸° ìœ„í•œ í•¨ìˆ˜ìž…ë‹ˆë‹¤."""
        self.log_textbox.configure(state="normal")
        self.log_textbox.insert("end", text)
        self.log_textbox.see("end")
        self.log_textbox.configure(state="disabled")

    def update_progress(self, value):
        """ìŠ¤ë ˆë“œë¡œë¶€í„° ë°›ì€ ê°’ìœ¼ë¡œ í”„ë¡œê·¸ë ˆìŠ¤ ë°”ë¥¼ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤."""
        self.progress.set(value)

    def set_ui_state(self, is_active):
        """ë²ˆì—­ ì¤‘/ì™„ë£Œ ì‹œ UI ìƒíƒœë¥¼ ë³€ê²½í•˜ì—¬ ì‚¬ìš©ìž ì‹¤ìˆ˜ë¥¼ ë°©ì§€í•©ë‹ˆë‹¤."""
        self.is_translating = is_active
        state = "disabled" if is_active else "normal"
        self.translate_btn.configure(state=state, text="ë²ˆì—­ ì¤‘..." if is_active else "ðŸš€ ë²ˆì—­ ì‹œìž‘í•˜ê¸°")
        for widget in self.root.winfo_children():
            if isinstance(widget, ctk.CTkFrame):
                for child in widget.winfo_children():
                    if child != self.translate_btn and child.master != self.progress.master:
                        try:
                            child.configure(state=state)
                        except:
                             pass

    def start_translation(self):
        """'ë²ˆì—­ ì‹œìž‘' ë²„íŠ¼ í´ë¦­ ì‹œ í˜¸ì¶œë˜ëŠ” ë©”ì¸ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ìž…ë‹ˆë‹¤."""
        if not self.file_path.get():
            messagebox.showerror("ìž…ë ¥ ì˜¤ë¥˜", "ë²ˆì—­í•  PDF íŒŒì¼ì„ ì„ íƒí•´ì£¼ì„¸ìš”.")
            return
        if not self.api_key.get():
            messagebox.showerror("ìž…ë ¥ ì˜¤ë¥˜", "Gemini API í‚¤ë¥¼ ìž…ë ¥í•´ì£¼ì„¸ìš”.")
            return
        self.set_ui_state(True)
        self.progress.set(0)
        self.log_textbox.configure(state="normal")
        self.log_textbox.delete("1.0", "end")
        self.log_textbox.configure(state="disabled")
        self.update_log("ë²ˆì—­ í”„ë¡œì„¸ìŠ¤ë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤...\n")
        thread = threading.Thread(target=self.run_translation_process)
        thread.daemon = True
        thread.start()

    def run_translation_process(self):
        """ì‹¤ì œ ë²ˆì—­ ëª…ë ¹ì„ ì‹¤í–‰í•˜ê³  ì‹¤ì‹œê°„ìœ¼ë¡œ ë¡œê·¸ì™€ ì§„í–‰ë¥ ì„ ë°›ì•„ì˜¤ëŠ” í•µì‹¬ ë¡œì§ìž…ë‹ˆë‹¤."""
        try:
            babeldoc_entry_point = BASE_PATH / "babeldoc" / "main.py"
            
            cmd = [
                sys.executable, str(babeldoc_entry_point),
                "--files", self.file_path.get(),
                "--lang-out", self.target_lang.get().split()[0],
                "--gemini",
                "--gemini-model", self.ai_model.get(),
                "--gemini-api-key", self.api_key.get(),
                "--watermark-output-mode", "no_watermark",
                "--report-interval", "1" 
            ]

            if self.output_format.get() == "mono":
                cmd.append("--no-dual")
            elif self.output_format.get() == "dual":
                cmd.append("--no-mono")
            
            self.root.after(0, self.update_log, f"ì‹¤í–‰ ëª…ë ¹ì–´: {' '.join(cmd)}\n\n")

            process = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, 
                                       text=True, encoding='utf-8', bufsize=1, 
                                       creationflags=subprocess.CREATE_NO_WINDOW if sys.platform == 'win32' else 0)

            for line in iter(process.stdout.readline, ''):
                self.root.after(0, self.update_log, line)
                
                progress_match = re.search(r"Progress: (\d+\.\d+)%", line)
                if progress_match:
                    progress_percent = float(progress_match.group(1))
                    self.root.after(0, self.update_progress, progress_percent / 100.0)
            
            process.stdout.close()
            return_code = process.wait()

            if return_code == 0:
                self.root.after(0, self.update_log, "\nðŸŽ‰ ë²ˆì—­ì´ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
                self.root.after(0, lambda: self.progress.set(1.0))
                self.root.after(0, lambda: messagebox.showinfo("ì„±ê³µ", "PDF ë²ˆì—­ì´ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!"))
            else:
                self.root.after(0, self.update_log, f"\nâŒ ì˜¤ë¥˜ ë°œìƒ! (ì¢…ë£Œ ì½”ë“œ: {return_code}) ë¡œê·¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.")
                self.root.after(0, lambda: messagebox.showerror("ì˜¤ë¥˜", "ë²ˆì—­ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ë¡œê·¸ë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”."))

        except Exception as e:
            error_msg = f"\nâŒ ì¹˜ëª…ì  ì˜¤ë¥˜ ë°œìƒ: {e}"
            self.root.after(0, self.update_log, error_msg)
            self.root.after(0, lambda: messagebox.showerror("ì¹˜ëª…ì  ì˜¤ë¥˜", str(e)))
        finally:
            self.root.after(0, self.set_ui_state, False)

    def run(self):
        self.root.mainloop()

if __name__ == "__main__":
    app = PDFTranslatorGUI()
    app.run()

3.6. í¬í„°ë¸” EXE ë¹Œë“œ (build_exe.py)
PyInstallerë¥¼ ì‚¬ìš©í•˜ì—¬ ë³µìž¡í•œ Python í”„ë¡œì íŠ¸ë¥¼ ëˆ„êµ¬ë‚˜ ì‰½ê²Œ ì‹¤í–‰í•  ìˆ˜ ìžˆëŠ” ë‹¨ì¼ .exe íŒŒì¼ë¡œ íŒ¨í‚¤ì§•í•©ë‹ˆë‹¤. ì´ ìŠ¤í¬ë¦½íŠ¸ëŠ” ìˆ¨ê²¨ì§„ ì˜ì¡´ì„±ì„ ì°¾ì•„ë‚´ê³ , í•„ìš”í•œ ë°ì´í„° íŒŒì¼ì„ í¬í•¨ì‹œí‚¤ëŠ” ë“± ë¹Œë“œ ê³¼ì •ì˜ ëª¨ë“  ë³µìž¡ì„±ì„ ìžë™í™”í•©ë‹ˆë‹¤.
# build_exe.py

import PyInstaller.__main__
import shutil
from pathlib import Path
import os

APP_NAME = "PDFë²ˆì—­ê¸°_ë‚¨ê´‘í˜„_Test"
MAIN_SCRIPT = "gui/main_window.py"
ICON_FILE = "assets/icon.ico"
DIST_PATH = "dist"

def build_portable_exe():
    """
    PyInstallerë¥¼ ì‚¬ìš©í•˜ì—¬ ëª¨ë“  ì˜ì¡´ì„±ì„ í¬í•¨í•˜ëŠ” í¬í„°ë¸” EXE íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.
    BabelDOC ëª¨ë“ˆ, ë°ì´í„° íŒŒì¼, ìˆ¨ê²¨ì§„ importë¥¼ ëª¨ë‘ ì²˜ë¦¬í•©ë‹ˆë‹¤.
    """
    workpath = "build"
    specpath = "."
    
    # ì´ì „ ë¹Œë“œ ê³¼ì •ì—ì„œ ìƒì„±ëœ ë¶ˆí•„ìš”í•œ íŒŒì¼ë“¤ì„ ì •ë¦¬í•©ë‹ˆë‹¤.
    if os.path.exists(DIST_PATH):
        shutil.rmtree(DIST_PATH)
    if os.path.exists(workpath):
        shutil.rmtree(workpath)
    if os.path.exists(f"{APP_NAME}.spec"):
        os.remove(f"{APP_NAME}.spec")

    print(f"ðŸ”¨ PyInstallerë¡œ '{APP_NAME}.exe' ë¹Œë“œë¥¼ ì‹œìž‘í•©ë‹ˆë‹¤...")

    # PyInstaller ëª…ë ¹ì–´ì— ì „ë‹¬í•  ì¸ìˆ˜ë¥¼ ë¦¬ìŠ¤íŠ¸ë¡œ êµ¬ì„±í•©ë‹ˆë‹¤.
    pyinstaller_args = [
        '--name', APP_NAME,
        '--onefile', # ëª¨ë“  ê²ƒì„ í•˜ë‚˜ì˜ .exe íŒŒì¼ë¡œ ë¬¶ìŠµë‹ˆë‹¤.
        '--windowed',  # GUI ì• í”Œë¦¬ì¼€ì´ì…˜ì´ë¯€ë¡œ ì‹¤í–‰ ì‹œ ê²€ì€ ì½˜ì†” ì°½ì´ ëœ¨ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
        '--icon', ICON_FILE,
        '--distpath', DIST_PATH,
        '--workpath', workpath,
        '--specpath', specpath,
        '--clean', # ë¹Œë“œ ì „ ì´ì „ ìºì‹œë¥¼ ì •ë¦¬í•©ë‹ˆë‹¤.
    ]

    # --- ë°ì´í„° íŒŒì¼ ì¶”ê°€ ---
    # --add-data 'ì›ë³¸ê²½ë¡œ;ëŒ€ìƒê²½ë¡œ' í˜•ì‹ìœ¼ë¡œ .exe íŒŒì¼ ë‚´ì— í¬í•¨ë  íŒŒì¼ì„ ì§€ì •í•©ë‹ˆë‹¤.
    pyinstaller_args.extend(['--add-data', 'babeldoc/assets;babeldoc/assets'])
    pyinstaller_args.extend(['--add-data', 'config.json;.'])

    # --- ìˆ¨ê²¨ì§„ Import ì¶”ê°€ ---
    # PyInstallerê°€ ì •ì  ë¶„ì„ë§Œìœ¼ë¡œëŠ” ì°¾ì•„ë‚´ì§€ ëª»í•˜ëŠ”, ë™ì ìœ¼ë¡œ ë¡œë“œë˜ëŠ” ë¼ì´ë¸ŒëŸ¬ë¦¬ë“¤ì„ ëª…ì‹œì ìœ¼ë¡œ ì¶”ê°€í•©ë‹ˆë‹¤.
    # ì´ ë¶€ë¶„ì´ ëˆ„ë½ë˜ë©´ .exe ì‹¤í–‰ ì‹œ 'ModuleNotFoundError' ì˜¤ë¥˜ê°€ ë°œìƒí•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
    hidden_imports = [
        'google.generativeai', 'google.ai.generativelanguage', 'google.auth',
        'google_auth_oauthlib', 'google.api_core.bidi', 'google.api_core.client_options',
        'google.api_core.exceptions', 'google.api_core.future', 'google.api_core.gapic_v1',
        'google.api_core.grpc_helpers', 'google.api_core.path_template',
        'customtkinter', 'PIL', 'darkdetect',
        'flask', 'werkzeug', 'jinja2', 'itsdangerous', 'click',
        'keyring.backends.Windows', 'keyring.backends.SecretService', 'keyring.backends.macOS',
        'babeldoc', 're'
    ]
    for imp in hidden_imports:
        pyinstaller_args.extend(['--hidden-import', imp])

    # ë¹Œë“œí•  ë©”ì¸ ìŠ¤í¬ë¦½íŠ¸ íŒŒì¼
    pyinstaller_args.append(MAIN_SCRIPT)

    print(f"ì‹¤í–‰ ì¸ìˆ˜: {' '.join(pyinstaller_args)}")

    try:
        PyInstaller.__main__.run(pyinstaller_args)
        print("\n" + "="*50)
        print(f"âœ… ë¹Œë“œê°€ ì„±ê³µì ìœ¼ë¡œ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤!")
        print(f"ê²°ê³¼ë¬¼ì€ '{os.path.abspath(DIST_PATH)}' í´ë”ì—ì„œ í™•ì¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.")
        print("="*50)
    except Exception as e:
        print("\n" + "!"*50)
        print(f"âŒ ë¹Œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {e}")
        print("!"*50)

if __name__ == "__main__":
    if not os.path.exists(ICON_FILE):
        print(f"ê²½ê³ : ì•„ì´ì½˜ íŒŒì¼({ICON_FILE})ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. ê¸°ë³¸ ì•„ì´ì½˜ìœ¼ë¡œ ë¹Œë“œë©ë‹ˆë‹¤.")
    build_portable_exe()

3.7. ì˜ì¡´ì„± íŒŒì¼ (requirements.txt)
# ì´ íŒŒì¼ì€ 'pip install -r requirements.txt' ëª…ë ¹ì–´ë¡œ í”„ë¡œì íŠ¸ì— í•„ìš”í•œ ëª¨ë“  ë¼ì´ë¸ŒëŸ¬ë¦¬ë¥¼ í•œ ë²ˆì— ì„¤ì¹˜í•  ìˆ˜ ìžˆê²Œ í•´ì¤ë‹ˆë‹¤.

# í•µì‹¬ ë²ˆì—­ ì—”ì§„
babeldoc>=1.0.0

# Google Gemini API í†µì‹ ìš© ë¼ì´ë¸ŒëŸ¬ë¦¬
google-generativeai>=0.5.0

# í˜„ëŒ€ì ì¸ GUI êµ¬í˜„ì„ ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
customtkinter>=5.2.2

# ë¡œì»¬ ë¸Œë¦¿ì§€ ì„œë²„ êµ¬í˜„ì„ ìœ„í•œ ì›¹ í”„ë ˆìž„ì›Œí¬
Flask>=3.0.0

# Python ìŠ¤í¬ë¦½íŠ¸ë¥¼ .exe íŒŒì¼ë¡œ ë¹Œë“œí•˜ê¸° ìœ„í•œ ë„êµ¬
PyInstaller>=6.0.0

# (ì„ íƒì‚¬í•­) API í‚¤ë¥¼ ì•ˆì „í•˜ê²Œ ì €ìž¥í•˜ê¸° ìœ„í•œ ë¼ì´ë¸ŒëŸ¬ë¦¬
keyring>=25.0.0
cryptography>=42.0.0

# customtkinterì´ ë‚´ë¶€ì ìœ¼ë¡œ ì‚¬ìš©í•˜ëŠ” ì´ë¯¸ì§€ ì²˜ë¦¬ ë¼ì´ë¸ŒëŸ¬ë¦¬
Pillow>=10.0.0
darkdetect>=0.8.0
